<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>I'm Not A Robot</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Space Mono', monospace;
    background: #000;
    color: #fff;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  .screen {
    display: none;
    flex-direction: column;
    align-items: center;
    text-align: center;
    padding: 2rem;
    max-width: 660px;
    width: 100%;
  }
  .screen.active { display: flex; }

  h1 {
    font-size: 2.4rem;
    font-weight: 700;
    color: #fff;
    margin-bottom: 1.5rem;
  }

  h2 {
    font-size: 1.5rem;
    font-weight: 700;
    color: #fff;
    margin-bottom: 0.5rem;
  }

  .btn {
    font-family: 'Space Mono', monospace;
    font-size: 1rem;
    font-weight: 700;
    padding: 0.7rem 2rem;
    border: 1px solid #fff;
    background: transparent;
    color: #fff;
    cursor: pointer;
    border-radius: 0;
    transition: all 0.15s;
  }
  .btn:hover {
    background: #f5f0e8;
    color: #000;
  }
  .btn:active {
    transform: scale(0.97);
  }

  .btn-secondary {
    border-color: #444;
    color: #888;
  }
  .btn-secondary:hover {
    background: #222;
    color: #fff;
    border-color: #444;
  }

  /* Challenge screen */
  .challenge-area {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    align-items: center;
    margin: 1rem 0;
  }

  .canvas-wrapper {
    position: relative;
  }
  .canvas-wrapper label {
    display: block;
    font-weight: 700;
    font-size: 0.75rem;
    margin-bottom: 0.4rem;
    color: #888;
  }

  canvas {
    border: 1px solid #333;
    border-radius: 0;
    background: #f5f0e8;
    cursor: crosshair;
    touch-action: none;
  }

  .draw-label {
    font-size: 0.85rem;
    color: #888;
    margin-top: 0.5rem;
  }

  /* Interactive challenge elements */
  .interactive-box {
    width: 220px;
    min-height: 220px;
    border: 1px solid #333;
    background: #f5f0e8;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1.5rem;
    gap: 1rem;
  }

  .interactive-box input[type="text"] {
    font-family: 'Space Mono', monospace;
    font-size: 1rem;
    padding: 0.5rem;
    border: 1px solid #999;
    background: #fff;
    color: #000;
    text-align: center;
    width: 80%;
  }

  .interactive-box .prompt-word {
    font-size: 1.4rem;
    font-weight: 700;
    color: #000;
    letter-spacing: 0.1em;
  }

  .interactive-box .prompt-text {
    font-size: 0.85rem;
    color: #555;
    text-align: center;
    line-height: 1.5;
  }

  .interactive-box .math-problem {
    font-size: 2rem;
    font-weight: 700;
    color: #000;
  }

  /* Slider */
  .slider-track {
    width: 180px;
    height: 8px;
    background: #ddd;
    position: relative;
    cursor: pointer;
    border: 1px solid #999;
  }
  .slider-thumb {
    width: 16px;
    height: 24px;
    background: #000;
    position: absolute;
    top: -9px;
    left: 0;
    cursor: grab;
  }
  .slider-label {
    font-size: 0.8rem;
    color: #555;
  }

  /* Color match */
  .color-target {
    width: 60px;
    height: 60px;
    border: 1px solid #999;
  }
  .color-preview {
    width: 60px;
    height: 60px;
    border: 1px solid #999;
  }
  .color-slider-wrap {
    width: 180px;
    position: relative;
  }
  .color-spectrum {
    width: 100%;
    height: 16px;
    border: 1px solid #999;
    cursor: pointer;
  }
  .color-slider-thumb {
    width: 4px;
    height: 24px;
    background: #000;
    position: absolute;
    top: -4px;
    left: 0;
    pointer-events: none;
  }

  /* Timer circle */
  .timer-display {
    font-size: 3rem;
    font-weight: 700;
    color: #000;
  }
  .timer-sub {
    font-size: 0.8rem;
    color: #555;
  }

  /* Fake words */
  .word-options {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    width: 100%;
  }
  .word-btn {
    font-family: 'Space Mono', monospace;
    font-size: 0.9rem;
    padding: 0.5rem;
    border: 1px solid #999;
    background: #fff;
    color: #000;
    cursor: pointer;
    transition: background 0.1s;
  }
  .word-btn:hover {
    background: #ddd;
  }

  .buttons-row {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
  }

  .result-message {
    font-size: 1.2rem;
    color: #fff;
    margin-bottom: 1.5rem;
  }

  .stats-box {
    width: 220px;
    height: 220px;
    border: 1px solid #333;
    background: #f5f0e8;
    display: none;
    align-items: center;
    justify-content: center;
    margin-bottom: 1.5rem;
  }

  .catch-stats {
    font-size: 0.85rem;
    color: #000;
    line-height: 2;
    text-align: center;
  }

  #overlayCanvas {
    cursor: default;
    margin-bottom: 1.5rem;
  }

  @media (max-width: 500px) {
    h1 { font-size: 1.6rem; }
    .challenge-area { gap: 0.8rem; }
    canvas { width: 200px; height: 200px; }
  }
</style>
</head>
<body>

<!-- CHALLENGE SCREEN (start screen) -->
<div id="challenge" class="screen active">
  <h1>I'm Not a Robot</h1>
  <div class="challenge-area">
    <div class="canvas-wrapper" id="referenceWrapper">
      <label>Target</label>
      <canvas id="referenceCanvas" width="220" height="220"></canvas>
    </div>
    <span class="draw-label" id="drawLabel">Draw the circle here:</span>
    <div class="canvas-wrapper" id="drawWrapper">
      <canvas id="drawCanvas" width="220" height="220"></canvas>
    </div>
    <div class="interactive-box" id="interactiveBox"></div>
  </div>
  <div class="buttons-row" id="buttonsRow">
    <button class="btn btn-secondary" id="clearBtn">Clear</button>
    <button class="btn" id="submitBtn">Submit</button>
  </div>
</div>

<!-- RESULTS SCREEN -->
<div id="results" class="screen">
  <p id="resultMessage" class="result-message">You are human, well done.</p>
  <canvas id="overlayCanvas" width="220" height="220"></canvas>
  <div id="catchStatsBox" class="stats-box">
    <p id="catchStats" class="catch-stats"></p>
  </div>
  <div class="buttons-row">
    <button class="btn" id="retryBtn">Try Again</button>
  </div>
</div>

<script>
  // --- State ---
  const screens = { challenge: document.getElementById('challenge'), results: document.getElementById('results') };
  let drawing = false;
  let points = [];
  let strokes = [];
  let currentChallenge = null;
  let dotsImageData = null;

  // --- Draw challenges (freehand) ---
  const drawChallenges = [
    {
      type: 'draw', name: 'circle',
      draw(ctx) { ctx.beginPath(); ctx.arc(110, 110, 75, 0, Math.PI * 2); ctx.stroke(); }
    },
    {
      type: 'draw', name: 'square',
      draw(ctx) { ctx.strokeRect(40, 40, 140, 140); }
    },
    {
      type: 'draw', name: 'triangle',
      draw(ctx) { ctx.beginPath(); ctx.moveTo(110, 30); ctx.lineTo(195, 180); ctx.lineTo(25, 180); ctx.closePath(); ctx.stroke(); }
    },
    {
      type: 'draw', name: 'smiley face',
      draw(ctx) {
        ctx.beginPath(); ctx.arc(110, 110, 75, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(85, 90, 8, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(135, 90, 8, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(110, 115, 40, 0.2, Math.PI - 0.2); ctx.stroke();
      }
    },
    {
      type: 'draw', name: 'pig',
      draw(ctx) {
        ctx.beginPath(); ctx.arc(110, 115, 65, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(65, 65); ctx.lineTo(50, 35); ctx.lineTo(80, 55); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(155, 65); ctx.lineTo(170, 35); ctx.lineTo(140, 55); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(110, 130, 25, 18, 0, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(100, 130, 5, 4, 0, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(120, 130, 5, 4, 0, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(88, 100, 5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(132, 100, 5, 0, Math.PI * 2); ctx.fill();
      }
    },
    {
      type: 'draw', name: 'mouse',
      draw(ctx) {
        ctx.beginPath(); ctx.arc(110, 120, 55, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(65, 70, 30, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(155, 70, 30, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(93, 110, 5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(127, 110, 5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(110, 130, 5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(80, 135); ctx.lineTo(40, 128); ctx.moveTo(80, 140); ctx.lineTo(40, 145); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(140, 135); ctx.lineTo(180, 128); ctx.moveTo(140, 140); ctx.lineTo(180, 145); ctx.stroke();
      }
    },
    {
      // Horse side profile
      type: 'draw', name: 'horse',
      draw(ctx) {
        // Head
        ctx.beginPath();
        ctx.moveTo(25, 80);
        ctx.quadraticCurveTo(20, 105, 30, 120);
        ctx.quadraticCurveTo(35, 130, 45, 125);
        ctx.quadraticCurveTo(50, 115, 50, 105);
        ctx.quadraticCurveTo(55, 90, 50, 75);
        ctx.quadraticCurveTo(45, 60, 35, 55);
        ctx.quadraticCurveTo(25, 55, 25, 80);
        ctx.stroke();
        // Ear
        ctx.beginPath();
        ctx.moveTo(38, 58);
        ctx.lineTo(42, 40);
        ctx.lineTo(48, 58);
        ctx.stroke();
        // Eye
        ctx.beginPath();
        ctx.arc(38, 80, 3, 0, Math.PI * 2);
        ctx.fill();
        // Nostril
        ctx.beginPath();
        ctx.arc(30, 112, 2, 0, Math.PI * 2);
        ctx.fill();
        // Neck + body
        ctx.beginPath();
        ctx.moveTo(50, 75);
        ctx.quadraticCurveTo(80, 60, 100, 80);
        ctx.quadraticCurveTo(140, 85, 170, 90);
        ctx.quadraticCurveTo(190, 95, 195, 110);
        ctx.stroke();
        // Belly
        ctx.beginPath();
        ctx.moveTo(50, 125);
        ctx.quadraticCurveTo(70, 140, 90, 150);
        ctx.quadraticCurveTo(130, 160, 170, 150);
        ctx.quadraticCurveTo(185, 145, 190, 130);
        ctx.stroke();
        // Front leg
        ctx.beginPath();
        ctx.moveTo(80, 148);
        ctx.lineTo(75, 195);
        ctx.lineTo(85, 195);
        ctx.lineTo(90, 148);
        ctx.stroke();
        // Back leg
        ctx.beginPath();
        ctx.moveTo(165, 145);
        ctx.lineTo(160, 195);
        ctx.lineTo(170, 195);
        ctx.lineTo(175, 140);
        ctx.stroke();
        // Tail
        ctx.beginPath();
        ctx.moveTo(195, 108);
        ctx.quadraticCurveTo(210, 95, 205, 115);
        ctx.quadraticCurveTo(200, 130, 195, 120);
        ctx.stroke();
        // Mane
        ctx.beginPath();
        ctx.moveTo(45, 58);
        ctx.quadraticCurveTo(60, 50, 75, 55);
        ctx.quadraticCurveTo(85, 58, 95, 70);
        ctx.stroke();
      }
    },
    {
      // Pig side profile
      type: 'draw', name: 'pig (side)',
      draw(ctx) {
        // Body (big oval)
        ctx.beginPath();
        ctx.ellipse(120, 120, 70, 50, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Head
        ctx.beginPath();
        ctx.arc(45, 110, 35, 0, Math.PI * 2);
        ctx.stroke();
        // Snout
        ctx.beginPath();
        ctx.ellipse(15, 115, 12, 9, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Nostrils
        ctx.beginPath();
        ctx.arc(12, 113, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(18, 113, 2, 0, Math.PI * 2);
        ctx.fill();
        // Eye
        ctx.beginPath();
        ctx.arc(40, 102, 4, 0, Math.PI * 2);
        ctx.fill();
        // Ear
        ctx.beginPath();
        ctx.moveTo(50, 82);
        ctx.lineTo(42, 65);
        ctx.lineTo(58, 75);
        ctx.closePath();
        ctx.stroke();
        // Front legs
        ctx.beginPath();
        ctx.moveTo(80, 165);
        ctx.lineTo(78, 200);
        ctx.moveTo(95, 168);
        ctx.lineTo(93, 200);
        ctx.stroke();
        // Back legs
        ctx.beginPath();
        ctx.moveTo(150, 165);
        ctx.lineTo(148, 200);
        ctx.moveTo(165, 163);
        ctx.lineTo(163, 200);
        ctx.stroke();
        // Curly tail
        ctx.beginPath();
        ctx.moveTo(190, 105);
        ctx.quadraticCurveTo(205, 95, 200, 85);
        ctx.quadraticCurveTo(195, 78, 205, 75);
        ctx.stroke();
      }
    },
    {
      // Mouse side profile
      type: 'draw', name: 'mouse (side)',
      draw(ctx) {
        // Body
        ctx.beginPath();
        ctx.ellipse(120, 130, 65, 40, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Head
        ctx.beginPath();
        ctx.ellipse(55, 115, 30, 28, -0.3, 0, Math.PI * 2);
        ctx.stroke();
        // Big ear
        ctx.beginPath();
        ctx.arc(55, 78, 18, 0, Math.PI * 2);
        ctx.stroke();
        // Eye
        ctx.beginPath();
        ctx.arc(42, 108, 4, 0, Math.PI * 2);
        ctx.fill();
        // Nose
        ctx.beginPath();
        ctx.arc(27, 118, 3, 0, Math.PI * 2);
        ctx.fill();
        // Whiskers
        ctx.beginPath();
        ctx.moveTo(30, 120);
        ctx.lineTo(8, 112);
        ctx.moveTo(30, 124);
        ctx.lineTo(8, 128);
        ctx.moveTo(30, 128);
        ctx.lineTo(10, 140);
        ctx.stroke();
        // Legs
        ctx.beginPath();
        ctx.moveTo(85, 165);
        ctx.lineTo(83, 195);
        ctx.moveTo(100, 168);
        ctx.lineTo(98, 195);
        ctx.moveTo(145, 168);
        ctx.lineTo(143, 195);
        ctx.moveTo(160, 165);
        ctx.lineTo(158, 195);
        ctx.stroke();
        // Long tail
        ctx.beginPath();
        ctx.moveTo(185, 125);
        ctx.quadraticCurveTo(210, 110, 205, 140);
        ctx.quadraticCurveTo(200, 160, 210, 170);
        ctx.stroke();
      }
    },
    {
      // Cat side profile
      type: 'draw', name: 'cat',
      draw(ctx) {
        // Body
        ctx.beginPath();
        ctx.ellipse(115, 125, 60, 40, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Head
        ctx.beginPath();
        ctx.arc(50, 100, 28, 0, Math.PI * 2);
        ctx.stroke();
        // Left ear
        ctx.beginPath();
        ctx.moveTo(35, 78);
        ctx.lineTo(30, 55);
        ctx.lineTo(48, 72);
        ctx.stroke();
        // Right ear
        ctx.beginPath();
        ctx.moveTo(55, 75);
        ctx.lineTo(60, 52);
        ctx.lineTo(68, 78);
        ctx.stroke();
        // Eye
        ctx.beginPath();
        ctx.ellipse(42, 97, 5, 4, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(42, 97, 2, 0, Math.PI * 2);
        ctx.fill();
        // Nose
        ctx.beginPath();
        ctx.moveTo(28, 105);
        ctx.lineTo(25, 110);
        ctx.lineTo(31, 110);
        ctx.closePath();
        ctx.fill();
        // Whiskers
        ctx.beginPath();
        ctx.moveTo(28, 110);
        ctx.lineTo(5, 105);
        ctx.moveTo(28, 112);
        ctx.lineTo(5, 115);
        ctx.stroke();
        // Legs
        ctx.beginPath();
        ctx.moveTo(80, 160);
        ctx.lineTo(78, 198);
        ctx.moveTo(95, 163);
        ctx.lineTo(93, 198);
        ctx.moveTo(140, 163);
        ctx.lineTo(138, 198);
        ctx.moveTo(155, 160);
        ctx.lineTo(153, 198);
        ctx.stroke();
        // Tail (curving up)
        ctx.beginPath();
        ctx.moveTo(175, 115);
        ctx.quadraticCurveTo(200, 100, 200, 70);
        ctx.quadraticCurveTo(200, 50, 190, 45);
        ctx.stroke();
      }
    }
  ];

  // --- Connect-the-dots challenges (freehand draw over numbered dots) ---
  const dotChallenges = [
    {
      // T-rex side profile: big head, tiny arms, thick tail, two legs
      type: 'dots', name: 'dinosaur',
      dots: [
        {x:60,y:45}, {x:40,y:55}, {x:25,y:70}, {x:20,y:90}, {x:25,y:105},
        {x:40,y:110}, {x:35,y:120}, {x:45,y:125}, {x:55,y:115},
        {x:60,y:130}, {x:55,y:160}, {x:50,y:195}, {x:70,y:195},
        {x:75,y:170}, {x:90,y:160}, {x:105,y:170}, {x:100,y:195},
        {x:120,y:195}, {x:125,y:165}, {x:130,y:150}, {x:145,y:140},
        {x:165,y:135}, {x:185,y:140}, {x:200,y:130}, {x:195,y:120},
        {x:175,y:115}, {x:150,y:110}, {x:130,y:100}, {x:110,y:80},
        {x:95,y:60}, {x:80,y:45}
      ]
    },
    {
      // Pig side profile: round body, snout, curly tail, short legs
      type: 'dots', name: 'pig',
      dots: [
        {x:30,y:90}, {x:20,y:100}, {x:18,y:115}, {x:25,y:125},
        {x:40,y:120}, {x:45,y:110}, {x:50,y:120}, {x:50,y:140},
        {x:45,y:170}, {x:40,y:195}, {x:60,y:195}, {x:65,y:175},
        {x:75,y:160}, {x:110,y:160}, {x:125,y:175}, {x:120,y:195},
        {x:140,y:195}, {x:145,y:170}, {x:150,y:155}, {x:160,y:145},
        {x:170,y:150}, {x:185,y:145}, {x:195,y:135}, {x:185,y:130},
        {x:165,y:130}, {x:155,y:120}, {x:150,y:100}, {x:140,y:85},
        {x:120,y:75}, {x:100,y:72}, {x:80,y:75}, {x:60,y:80}, {x:45,y:85}
      ]
    },
    {
      // House: simple house with roof, door, chimney
      type: 'dots', name: 'house',
      dots: [
        {x:35,y:120}, {x:35,y:195}, {x:90,y:195}, {x:90,y:155},
        {x:130,y:155}, {x:130,y:195}, {x:185,y:195}, {x:185,y:120},
        {x:200,y:120}, {x:110,y:40}, {x:20,y:120}
      ]
    },
    {
      // Elephant side profile: big body, trunk, tusks, legs
      type: 'dots', name: 'elephant',
      dots: [
        {x:30,y:70}, {x:20,y:85}, {x:15,y:105}, {x:20,y:120},
        {x:15,y:140}, {x:10,y:165}, {x:20,y:175}, {x:30,y:155},
        {x:35,y:135}, {x:45,y:145}, {x:45,y:170}, {x:40,y:195},
        {x:60,y:195}, {x:65,y:170}, {x:75,y:155}, {x:105,y:155},
        {x:115,y:170}, {x:110,y:195}, {x:130,y:195}, {x:135,y:170},
        {x:140,y:155}, {x:160,y:155}, {x:170,y:170}, {x:165,y:195},
        {x:185,y:195}, {x:190,y:170}, {x:195,y:150}, {x:195,y:120},
        {x:185,y:95}, {x:170,y:78}, {x:150,y:68}, {x:125,y:62},
        {x:100,y:58}, {x:75,y:55}, {x:55,y:55}, {x:40,y:60}
      ]
    },
    {
      // Star: classic 5-pointed star
      type: 'dots', name: 'star',
      dots: [
        {x:110,y:20}, {x:125,y:80}, {x:190,y:85}, {x:140,y:125},
        {x:160,y:190}, {x:110,y:150}, {x:60,y:190}, {x:80,y:125},
        {x:30,y:85}, {x:95,y:80}
      ]
    }
  ];

  // --- Catch challenges (bouncing ball) ---
  const catchChallenges = [
    { type: 'catch', name: 'dot', radius: 15, speed: 2, clicks: 3 },
    { type: 'catch', name: 'dot', radius: 12, speed: 3, clicks: 3 },
    { type: 'catch', name: 'dot', radius: 10, speed: 4, clicks: 5 },
  ];

  // --- Interactive challenges ---
  const words = ['elephant', 'rainbow', 'kitchen', 'bicycle', 'penguin', 'blanket', 'thunder', 'dolphin', 'lantern', 'giraffe'];
  const mathProblems = [
    { q: '7 + 3', a: 10 }, { q: '12 - 5', a: 7 }, { q: '4 x 6', a: 24 },
    { q: '9 + 8', a: 17 }, { q: '15 - 9', a: 6 }, { q: '3 x 7', a: 21 },
    { q: '11 + 4', a: 15 }, { q: '20 - 13', a: 7 }, { q: '5 x 5', a: 25 }
  ];
  const fakeWordSets = [
    { real: ['lemon', 'carpet', 'window'], fake: 'flonkle' },
    { real: ['garden', 'silver', 'bottle'], fake: 'grindop' },
    { real: ['planet', 'bridge', 'forest'], fake: 'plumbot' },
    { real: ['candle', 'velvet', 'pillow'], fake: 'snorble' },
    { real: ['basket', 'tunnel', 'marble'], fake: 'crumpit' },
    { real: ['rocket', 'hammer', 'pencil'], fake: 'whibble' },
    { real: ['sunset', 'anchor', 'muffin'], fake: 'drongle' },
    { real: ['copper', 'jacket', 'turtle'], fake: 'flargen' },
  ];

  const interactiveChallenges = [
    { type: 'backward' },
    { type: 'math_wrong' },
    { type: 'slider' },
    { type: 'color' },
    { type: 'timer' },
    { type: 'straight_line' },
    { type: 'fake_word' },
    { type: 'shake' },
  ];

  const allChallenges = [...drawChallenges, ...dotChallenges, ...catchChallenges, ...interactiveChallenges];

  function pickRandomChallenge() {
    currentChallenge = allChallenges[Math.floor(Math.random() * allChallenges.length)];
  }

  // --- Catch state ---
  let ballX, ballY, ballDX, ballDY, catchCount, catchTarget, animFrame;
  let totalClicks, catchStartTime;

  // --- Interactive state ---
  let interactiveResult = null;
  let timerRunning = false;
  let timerStart = 0;
  let timerInterval = null;
  let shakePoints = [];
  let shakeAnimFrame = null;

  // --- Navigation ---
  function showScreen(name) {
    Object.values(screens).forEach(s => s.classList.remove('active'));
    screens[name].classList.add('active');
  }

  // --- Elements ---
  const refCanvas = document.getElementById('referenceCanvas');
  const refCtx = refCanvas.getContext('2d');
  const refWrapper = document.getElementById('referenceWrapper');
  const drawLabel = document.getElementById('drawLabel');
  const drawCanvas = document.getElementById('drawCanvas');
  const drawCtx = drawCanvas.getContext('2d');
  const drawWrapper = document.getElementById('drawWrapper');
  const interactiveBox = document.getElementById('interactiveBox');
  const buttonsRow = document.getElementById('buttonsRow');

  function drawDotsConnected(ctx, dots) {
    if (dots.length < 2) return;
    ctx.beginPath();
    ctx.moveTo(dots[0].x, dots[0].y);
    for (let i = 1; i < dots.length; i++) ctx.lineTo(dots[i].x, dots[i].y);
    ctx.closePath();
    ctx.stroke();
  }

  function drawNumberedDots(ctx, dots) {
    dots.forEach((dot, i) => {
      ctx.beginPath();
      ctx.arc(dot.x, dot.y, 8, 0, Math.PI * 2);
      ctx.fillStyle = '#ddd';
      ctx.fill();
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = '#000';
      ctx.font = '9px Space Mono, monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(i + 1, dot.x, dot.y);
    });
  }

  function getPos(e) {
    const rect = drawCanvas.getBoundingClientRect();
    const scaleX = drawCanvas.width / rect.width;
    const scaleY = drawCanvas.height / rect.height;
    if (e.touches) {
      return { x: (e.touches[0].clientX - rect.left) * scaleX, y: (e.touches[0].clientY - rect.top) * scaleY };
    }
    return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
  }

  // --- Freehand drawing ---
  function startDraw(e) {
    if (!['draw', 'dots', 'straight_line', 'shake'].includes(currentChallenge.type)) return;
    e.preventDefault();
    drawing = true;
    points = [];

    const p = getPos(e);
    points.push(p);
    drawCtx.beginPath();
    drawCtx.moveTo(p.x, p.y);
  }

  function moveDraw(e) {
    if (!drawing) return;
    if (!['draw', 'dots', 'straight_line', 'shake'].includes(currentChallenge.type)) return;
    e.preventDefault();
    const p = getPos(e);
    points.push(p);

    if (currentChallenge.type === 'shake') {
      shakePoints.push(p);
    }

    drawCtx.lineTo(p.x, p.y);
    drawCtx.strokeStyle = '#000';
    drawCtx.lineWidth = 2;
    drawCtx.lineCap = 'round';
    drawCtx.lineJoin = 'round';
    drawCtx.stroke();
    drawCtx.beginPath();
    drawCtx.moveTo(p.x, p.y);
  }

  function endDraw(e) {
    if (drawing) {
      e.preventDefault();
      drawing = false;
      if (points.length > 1) strokes.push([...points]);
    }
  }

  drawCanvas.addEventListener('mousedown', startDraw);
  drawCanvas.addEventListener('mousemove', moveDraw);
  drawCanvas.addEventListener('mouseup', endDraw);
  drawCanvas.addEventListener('mouseleave', endDraw);
  drawCanvas.addEventListener('touchstart', startDraw);
  drawCanvas.addEventListener('touchmove', moveDraw);
  drawCanvas.addEventListener('touchend', endDraw);

  // --- Catch: bouncing ball ---
  function initBall() {
    ballX = 110; ballY = 110;
    const angle = Math.random() * Math.PI * 2;
    const spd = currentChallenge.speed;
    ballDX = Math.cos(angle) * spd;
    ballDY = Math.sin(angle) * spd;
    catchCount = 0;
    catchTarget = currentChallenge.clicks;
    totalClicks = 0;
    catchStartTime = Date.now();
  }

  function animateBall() {
    if (currentChallenge.type !== 'catch') return;
    const w = drawCanvas.width, h = drawCanvas.height;
    const r = currentChallenge.radius;
    ballX += ballDX; ballY += ballDY;
    if (ballX - r <= 0 || ballX + r >= w) { ballDX *= -1; ballX = Math.max(r, Math.min(w - r, ballX)); }
    if (ballY - r <= 0 || ballY + r >= h) { ballDY *= -1; ballY = Math.max(r, Math.min(h - r, ballY)); }
    drawCtx.clearRect(0, 0, w, h);
    drawCtx.beginPath();
    drawCtx.arc(ballX, ballY, r, 0, Math.PI * 2);
    drawCtx.fillStyle = '#000';
    drawCtx.fill();
    drawCtx.fillStyle = '#999';
    drawCtx.font = '12px Space Mono, monospace';
    drawCtx.textAlign = 'right';
    drawCtx.textBaseline = 'top';
    drawCtx.fillText(catchCount + ' / ' + catchTarget, w - 8, 8);
    animFrame = requestAnimationFrame(animateBall);
  }

  function stopBall() { if (animFrame) { cancelAnimationFrame(animFrame); animFrame = null; } }

  function handleCatchAt(p) {
    totalClicks++;
    const dist = Math.sqrt((p.x - ballX) ** 2 + (p.y - ballY) ** 2);
    if (dist <= currentChallenge.radius + 5) {
      catchCount++;
      ballDX *= 1.15; ballDY *= 1.15;
      if (catchCount >= catchTarget) { stopBall(); showResults(); }
    }
  }

  drawCanvas.addEventListener('click', (e) => {
    if (currentChallenge.type !== 'catch') return;
    handleCatchAt(getPos(e));
  });
  drawCanvas.addEventListener('touchstart', (e) => {
    if (currentChallenge.type !== 'catch') return;
    e.preventDefault();
    handleCatchAt(getPos(e));
  });

  // --- Interactive challenge setup ---
  function setupInteractive() {
    interactiveBox.innerHTML = '';
    interactiveBox.style.display = 'flex';
    drawWrapper.style.display = 'none';
    refWrapper.style.display = 'none';
    interactiveResult = null;

    const type = currentChallenge.type;

    if (type === 'backward') {
      const word = words[Math.floor(Math.random() * words.length)];
      currentChallenge._word = word;
      currentChallenge._startTime = Date.now();
      interactiveBox.innerHTML =
        '<p class="prompt-text">Type this word backwards:</p>' +
        '<p class="prompt-word">' + word + '</p>' +
        '<input type="text" id="backwardInput" autocomplete="off" autocapitalize="off">';
      drawLabel.textContent = 'Type it backwards to prove you\'re human:';
      buttonsRow.style.display = '';
      setTimeout(() => document.getElementById('backwardInput')?.focus(), 100);

    } else if (type === 'math_wrong') {
      const prob = mathProblems[Math.floor(Math.random() * mathProblems.length)];
      currentChallenge._problem = prob;
      interactiveBox.innerHTML =
        '<p class="prompt-text">Answer this WRONG:</p>' +
        '<p class="math-problem">' + prob.q + ' = ?</p>' +
        '<input type="text" id="mathInput" autocomplete="off" inputmode="numeric">' +
        '<p class="prompt-text">(any wrong answer will do)</p>';
      drawLabel.textContent = 'Answer this wrong:';
      buttonsRow.style.display = '';
      setTimeout(() => document.getElementById('mathInput')?.focus(), 100);

    } else if (type === 'slider') {
      interactiveBox.innerHTML =
        '<p class="prompt-text">Drag the slider to exactly 50%:</p>' +
        '<div class="slider-track" id="sliderTrack"><div class="slider-thumb" id="sliderThumb"></div></div>';
      drawLabel.textContent = 'Drag the slider to exactly 50%:';
      buttonsRow.style.display = '';
      setupSlider();

    } else if (type === 'color') {
      const targetHue = Math.floor(Math.random() * 360);
      currentChallenge._targetHue = targetHue;
      currentChallenge._selectedHue = 0;
      const targetColor = 'hsl(' + targetHue + ', 70%, 50%)';
      interactiveBox.innerHTML =
        '<p class="prompt-text">Match this color:</p>' +
        '<div class="color-target" id="colorTarget" style="background:' + targetColor + '"></div>' +
        '<p class="prompt-text">Your pick:</p>' +
        '<div class="color-preview" id="colorPreview" style="background:hsl(0,70%,50%)"></div>' +
        '<div class="color-slider-wrap" id="colorSliderWrap">' +
        '<canvas class="color-spectrum" id="colorSpectrum" width="180" height="16"></canvas>' +
        '<div class="color-slider-thumb" id="colorThumb"></div>' +
        '</div>';
      drawLabel.textContent = 'Slide to match the color:';
      buttonsRow.style.display = '';
      // Draw spectrum
      setTimeout(() => {
        const specCanvas = document.getElementById('colorSpectrum');
        const sctx = specCanvas.getContext('2d');
        for (let x = 0; x < 180; x++) {
          sctx.fillStyle = 'hsl(' + Math.round((x / 180) * 360) + ', 70%, 50%)';
          sctx.fillRect(x, 0, 1, 16);
        }
        const wrap = document.getElementById('colorSliderWrap');
        const thumb = document.getElementById('colorThumb');
        const preview = document.getElementById('colorPreview');
        let dragging = false;
        function updateColor(clientX) {
          const rect = specCanvas.getBoundingClientRect();
          let pct = (clientX - rect.left) / rect.width;
          pct = Math.max(0, Math.min(1, pct));
          const hue = Math.round(pct * 360);
          currentChallenge._selectedHue = hue;
          thumb.style.left = (pct * 176) + 'px';
          preview.style.background = 'hsl(' + hue + ', 70%, 50%)';
        }
        specCanvas.addEventListener('mousedown', (e) => { dragging = true; updateColor(e.clientX); });
        document.addEventListener('mousemove', (e) => { if (dragging) updateColor(e.clientX); });
        document.addEventListener('mouseup', () => { dragging = false; });
        specCanvas.addEventListener('touchstart', (e) => { dragging = true; updateColor(e.touches[0].clientX); });
        document.addEventListener('touchmove', (e) => { if (dragging) updateColor(e.touches[0].clientX); });
        document.addEventListener('touchend', () => { dragging = false; });
      }, 50);

    } else if (type === 'timer') {
      interactiveBox.innerHTML =
        '<p class="prompt-text">Wait exactly 3 seconds, then click:</p>' +
        '<div class="timer-display" id="timerDisplay">—</div>' +
        '<button class="word-btn" id="timerBtn">Start</button>' +
        '<p class="timer-sub" id="timerSub">Click Start, then click Stop when you think 3s is up</p>';
      drawLabel.textContent = 'Wait exactly 3 seconds:';
      buttonsRow.style.display = 'none';

      let phase = 'ready'; // ready -> running -> done
      const btn = interactiveBox.querySelector('#timerBtn');
      const display = interactiveBox.querySelector('#timerDisplay');

      btn.addEventListener('click', () => {
        if (phase === 'ready') {
          phase = 'running';
          btn.textContent = 'Stop';
          display.textContent = '...';
          timerStart = Date.now();
        } else if (phase === 'running') {
          phase = 'done';
          const elapsed = (Date.now() - timerStart) / 1000;
          display.textContent = elapsed.toFixed(3) + 's';
          interactiveResult = { elapsed, diff: Math.abs(elapsed - 3), type: 'timer' };
          setTimeout(() => showResults(), 500);
        }
      });

    } else if (type === 'fake_word') {
      const set = fakeWordSets[Math.floor(Math.random() * fakeWordSets.length)];
      const allWords = [...set.real, set.fake];
      // Shuffle
      for (let i = allWords.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allWords[i], allWords[j]] = [allWords[j], allWords[i]];
      }
      currentChallenge._fake = set.fake;
      const fakeStartTime = Date.now();
      const btns = allWords.map(w =>
        '<button class="word-btn" data-word="' + w + '">' + w + '</button>'
      ).join('');
      interactiveBox.innerHTML =
        '<p class="prompt-text">Which word is fake?</p>' +
        '<div class="word-options">' + btns + '</div>';
      drawLabel.textContent = 'Only a human would know:';
      buttonsRow.style.display = 'none';
      interactiveBox.querySelectorAll('.word-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const elapsed = ((Date.now() - fakeStartTime) / 1000).toFixed(1);
          const correct = btn.dataset.word === set.fake;
          interactiveResult = { correct, picked: btn.dataset.word, fake: set.fake, type: 'fake_word', elapsed };
          showResults();
        });
      });
    }
  }

  // --- Slider logic ---
  function setupSlider() {
    const track = document.getElementById('sliderTrack');
    const thumb = document.getElementById('sliderThumb');
    let dragging = false;
    currentChallenge._sliderVal = 0;

    function updateSlider(clientX) {
      const rect = track.getBoundingClientRect();
      let pct = (clientX - rect.left) / rect.width;
      pct = Math.max(0, Math.min(1, pct));
      thumb.style.left = (pct * (rect.width - 16)) + 'px';
      currentChallenge._sliderVal = pct;
    }

    track.addEventListener('mousedown', (e) => { dragging = true; updateSlider(e.clientX); });
    document.addEventListener('mousemove', (e) => { if (dragging) updateSlider(e.clientX); });
    document.addEventListener('mouseup', () => { dragging = false; });
    track.addEventListener('touchstart', (e) => { dragging = true; updateSlider(e.touches[0].clientX); });
    document.addEventListener('touchmove', (e) => { if (dragging) updateSlider(e.touches[0].clientX); });
    document.addEventListener('touchend', () => { dragging = false; });
  }

  // --- Setup for straight line and shake (use canvas) ---
  function setupCanvasInteractive() {
    if (currentChallenge.type === 'straight_line') {
      drawLabel.textContent = 'Draw a perfectly straight line:';
      refWrapper.style.display = 'none';
      // Draw start and end dots
      drawCtx.fillStyle = '#999';
      drawCtx.beginPath();
      drawCtx.arc(30, 110, 6, 0, Math.PI * 2);
      drawCtx.fill();
      drawCtx.beginPath();
      drawCtx.arc(190, 110, 6, 0, Math.PI * 2);
      drawCtx.fill();
      drawCtx.fillStyle = '#aaa';
      drawCtx.font = '10px Space Mono, monospace';
      drawCtx.textAlign = 'center';
      drawCtx.fillText('A', 30, 95);
      drawCtx.fillText('B', 190, 95);
    } else if (currentChallenge.type === 'shake') {
      drawLabel.textContent = 'Scribble randomly inside the box:';
      refWrapper.style.display = 'none';
      shakePoints = [];
    }
  }

  // --- Clear ---
  function clearDrawing() {
    points = [];
    strokes = [];
    shakePoints = [];
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    if (currentChallenge.type === 'dots') {
      drawNumberedDots(drawCtx, currentChallenge.dots);
      dotsImageData = drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
    } else if (currentChallenge.type === 'catch') {
      stopBall(); initBall(); animateBall();
    } else if (currentChallenge.type === 'straight_line' || currentChallenge.type === 'shake') {
      setupCanvasInteractive();
    }
  }

  document.getElementById('clearBtn').addEventListener('click', clearDrawing);

  // --- Setup challenge ---
  function setupChallenge() {
    stopBall();
    if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
    points = [];
    strokes = [];
    shakePoints = [];
    interactiveResult = null;

    const type = currentChallenge.type;
    const isCanvas = ['draw', 'dots', 'catch', 'straight_line', 'shake'].includes(type);
    const isInteractive = ['backward', 'math_wrong', 'slider', 'color', 'timer', 'fake_word'].includes(type);

    drawWrapper.style.display = isCanvas ? '' : 'none';
    interactiveBox.style.display = isInteractive ? 'flex' : 'none';
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

    refCtx.clearRect(0, 0, refCanvas.width, refCanvas.height);
    refCtx.strokeStyle = '#000';
    refCtx.fillStyle = '#000';
    refCtx.lineWidth = 2;

    if (type === 'draw') {
      refWrapper.style.display = '';
      currentChallenge.draw(refCtx);
      drawLabel.textContent = 'Draw the ' + currentChallenge.name + ' here:';
      drawCanvas.style.cursor = 'crosshair';
      buttonsRow.style.display = '';
    } else if (type === 'dots') {
      refWrapper.style.display = 'none';
      drawLabel.textContent = 'Connect the dots:';
      drawCanvas.style.cursor = 'crosshair';
      buttonsRow.style.display = '';
      drawNumberedDots(drawCtx, currentChallenge.dots);
      dotsImageData = drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
    } else if (type === 'catch') {
      refWrapper.style.display = 'none';
      drawLabel.textContent = 'Click the bouncing dot ' + currentChallenge.clicks + ' times:';
      drawCanvas.style.cursor = 'pointer';
      buttonsRow.style.display = 'none';
      initBall(); animateBall();
    } else if (type === 'straight_line' || type === 'shake') {
      drawCanvas.style.cursor = 'crosshair';
      buttonsRow.style.display = '';
      setupCanvasInteractive();
    } else if (isInteractive) {
      setupInteractive();
    }
  }

  // Pick and setup on load
  pickRandomChallenge();
  setupChallenge();

  // --- Show results ---
  function showResults() {
    stopBall();
    if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }

    const overlayCanvas = document.getElementById('overlayCanvas');
    const octx = overlayCanvas.getContext('2d');
    octx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    const statsEl = document.getElementById('catchStats');
    const statsBox = document.getElementById('catchStatsBox');
    const resultMsg = document.getElementById('resultMessage');

    resultMsg.textContent = 'You are human, well done.';
    const type = currentChallenge.type;

    if (type === 'catch') {
      overlayCanvas.style.display = 'none';
      statsBox.style.display = 'flex';
      const elapsed = ((Date.now() - catchStartTime) / 1000).toFixed(1);
      const accuracy = Math.round((catchCount / totalClicks) * 100);
      statsEl.innerHTML = 'Time: ' + elapsed + 's<br>Accuracy: ' + catchCount + '/' + totalClicks + ' (' + accuracy + '%)';

    } else if (type === 'backward') {
      overlayCanvas.style.display = 'none';
      statsBox.style.display = 'flex';
      const input = document.getElementById('backwardInput');
      const answer = input ? input.value.toLowerCase().trim() : '';
      const expected = currentChallenge._word.split('').reverse().join('');
      const correct = answer === expected;
      const elapsed = ((Date.now() - (currentChallenge._startTime || Date.now())) / 1000).toFixed(1);
      if (correct) {
        statsEl.innerHTML = 'You typed this in ' + elapsed + ' seconds.<br>A robot would have been faster.';
      } else {
        statsEl.innerHTML = 'You typed: ' + (answer || '(nothing)') + '<br>Expected: ' + expected;
      }

    } else if (type === 'math_wrong') {
      overlayCanvas.style.display = 'none';
      statsBox.style.display = 'flex';
      const input = document.getElementById('mathInput');
      const answer = input ? parseInt(input.value.trim()) : NaN;
      const correct = !isNaN(answer) && answer !== currentChallenge._problem.a;
      if (isNaN(answer)) {
        statsEl.innerHTML = 'You didn\'t answer.<br>That\'s... also wrong. Human.';
      } else if (correct) {
        statsEl.innerHTML = 'You said: ' + answer + '<br>Correct answer: ' + currentChallenge._problem.a;
      } else {
        statsEl.innerHTML = 'You said: ' + answer + '<br>That\'s the RIGHT answer!<br>Suspicious...';
        resultMsg.textContent = 'Hmm, suspiciously correct.';
      }

    } else if (type === 'slider') {
      overlayCanvas.style.display = 'none';
      statsBox.style.display = 'flex';
      const val = currentChallenge._sliderVal || 0;
      const pct = Math.round(val * 100);
      const diff = Math.abs(pct - 50);
      statsEl.innerHTML = 'You got: ' + pct + '%<br>Off by ' + diff + '%';

    } else if (type === 'color') {
      overlayCanvas.style.display = 'none';
      statsBox.style.display = 'flex';
      const target = currentChallenge._targetHue || 0;
      const selected = currentChallenge._selectedHue || 0;
      let hueDiff = Math.abs(target - selected);
      if (hueDiff > 180) hueDiff = 360 - hueDiff;
      statsEl.innerHTML = 'Target: ' + target + '°<br>You picked: ' + selected + '°';

    } else if (type === 'timer') {
      overlayCanvas.style.display = 'none';
      statsBox.style.display = 'flex';
      if (interactiveResult) {
        const diff = interactiveResult.diff;
        const elapsed = interactiveResult.elapsed.toFixed(3);
        if (diff < 0.01) {
          statsEl.innerHTML = 'You got: ' + elapsed + 's<br>Off by ' + (diff * 1000).toFixed(0) + 'ms<br>Suspiciously accurate...';
          resultMsg.textContent = 'Too precise. Are you a clock?';
        } else if (diff < 0.3) {
          statsEl.innerHTML = 'You got: ' + elapsed + 's<br>Off by ' + (diff * 1000).toFixed(0) + 'ms<br>Pretty good for a human!';
        } else {
          statsEl.innerHTML = 'You got: ' + elapsed + 's<br>Off by ' + diff.toFixed(2) + 's<br>Terrible timing. Definitely human.';
        }
      }

    } else if (type === 'fake_word') {
      overlayCanvas.style.display = 'none';
      statsBox.style.display = 'flex';
      const fwElapsed = interactiveResult ? interactiveResult.elapsed : '?';
      if (interactiveResult && interactiveResult.correct) {
        statsEl.innerHTML = 'You picked: ' + interactiveResult.picked + '<br>Time: ' + fwElapsed + 's<br>Too slow to be a robot.';
      } else {
        statsEl.innerHTML = 'You picked: ' + (interactiveResult ? interactiveResult.picked : '?') + '<br>Time: ' + fwElapsed + 's<br>The fake was: ' + (interactiveResult ? interactiveResult.fake : '?') + '<br>Too slow to be a robot.';
      }

    } else if (type === 'straight_line') {
      overlayCanvas.style.display = '';
      statsBox.style.display = 'none';
      // Draw the perfect line (dim)
      octx.strokeStyle = '#ccc';
      octx.lineWidth = 2;
      octx.beginPath();
      octx.moveTo(30, 110);
      octx.lineTo(190, 110);
      octx.stroke();
      // Draw user strokes
      octx.strokeStyle = '#000';
      octx.lineWidth = 2;
      octx.lineCap = 'round';
      octx.lineJoin = 'round';
      const allStrokes = points.length > 1 ? [...strokes, points] : strokes;
      allStrokes.forEach(s => {
        if (s.length < 2) return;
        octx.beginPath();
        octx.moveTo(s[0].x, s[0].y);
        for (let i = 1; i < s.length; i++) octx.lineTo(s[i].x, s[i].y);
        octx.stroke();
      });

    } else if (type === 'shake') {
      overlayCanvas.style.display = '';
      statsBox.style.display = 'none';
      // Draw the user's scribble on overlay
      octx.strokeStyle = '#000';
      octx.lineWidth = 2;
      octx.lineCap = 'round';
      octx.lineJoin = 'round';
      const allStrokes = points.length > 1 ? [...strokes, points] : strokes;
      allStrokes.forEach(s => {
        if (s.length < 2) return;
        octx.beginPath();
        octx.moveTo(s[0].x, s[0].y);
        for (let i = 1; i < s.length; i++) octx.lineTo(s[i].x, s[i].y);
        octx.stroke();
      });

    } else {
      // draw / dots
      overlayCanvas.style.display = '';
      statsBox.style.display = 'none';
      if (type === 'draw') {
        octx.strokeStyle = '#ccc'; octx.fillStyle = '#ccc'; octx.lineWidth = 2;
        currentChallenge.draw(octx);
      } else if (type === 'dots') {
        octx.strokeStyle = '#ccc'; octx.fillStyle = '#ccc'; octx.lineWidth = 2;
        drawDotsConnected(octx, currentChallenge.dots);
      }
      octx.strokeStyle = '#000'; octx.fillStyle = 'transparent'; octx.lineWidth = 2;
      octx.lineCap = 'round'; octx.lineJoin = 'round';
      const allStrokes = points.length > 1 ? [...strokes, points] : strokes;
      allStrokes.forEach(s => {
        if (s.length < 2) return;
        octx.beginPath();
        octx.moveTo(s[0].x, s[0].y);
        for (let i = 1; i < s.length; i++) octx.lineTo(s[i].x, s[i].y);
        octx.stroke();
      });
    }

    showScreen('results');
  }

  // --- Submit ---
  document.getElementById('submitBtn').addEventListener('click', () => {
    const type = currentChallenge.type;
    if (type === 'catch') return;
    if (['draw', 'dots', 'straight_line', 'shake'].includes(type)) {
      if (strokes.length === 0 && points.length < 10) return;
    }
    showResults();
  });

  // --- Retry ---
  document.getElementById('retryBtn').addEventListener('click', () => {
    pickRandomChallenge();
    showScreen('challenge');
    setupChallenge();
  });
</script>
</body>
</html>
